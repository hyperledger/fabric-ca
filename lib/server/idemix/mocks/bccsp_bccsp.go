// Code generated by mockery v2.33.0. DO NOT EDIT.

package mocks

import (
	hash "hash"

	mock "github.com/stretchr/testify/mock"

	types "github.com/IBM/idemix/bccsp/types"
)

// BccspBCCSP is an autogenerated mock type for the BccspBCCSP type
type BccspBCCSP struct {
	mock.Mock
}

// Decrypt provides a mock function with given fields: k, ciphertext, opts
func (_m *BccspBCCSP) Decrypt(k types.Key, ciphertext []byte, opts types.DecrypterOpts) ([]byte, error) {
	ret := _m.Called(k, ciphertext, opts)

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Key, []byte, types.DecrypterOpts) ([]byte, error)); ok {
		return rf(k, ciphertext, opts)
	}
	if rf, ok := ret.Get(0).(func(types.Key, []byte, types.DecrypterOpts) []byte); ok {
		r0 = rf(k, ciphertext, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Key, []byte, types.DecrypterOpts) error); ok {
		r1 = rf(k, ciphertext, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Encrypt provides a mock function with given fields: k, plaintext, opts
func (_m *BccspBCCSP) Encrypt(k types.Key, plaintext []byte, opts types.EncrypterOpts) ([]byte, error) {
	ret := _m.Called(k, plaintext, opts)

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Key, []byte, types.EncrypterOpts) ([]byte, error)); ok {
		return rf(k, plaintext, opts)
	}
	if rf, ok := ret.Get(0).(func(types.Key, []byte, types.EncrypterOpts) []byte); ok {
		r0 = rf(k, plaintext, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Key, []byte, types.EncrypterOpts) error); ok {
		r1 = rf(k, plaintext, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHash provides a mock function with given fields: opts
func (_m *BccspBCCSP) GetHash(opts types.HashOpts) (hash.Hash, error) {
	ret := _m.Called(opts)

	var r0 hash.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(types.HashOpts) (hash.Hash, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(types.HashOpts) hash.Hash); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(hash.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(types.HashOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKey provides a mock function with given fields: ski
func (_m *BccspBCCSP) GetKey(ski []byte) (types.Key, error) {
	ret := _m.Called(ski)

	var r0 types.Key
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte) (types.Key, error)); ok {
		return rf(ski)
	}
	if rf, ok := ret.Get(0).(func([]byte) types.Key); ok {
		r0 = rf(ski)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.Key)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(ski)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Hash provides a mock function with given fields: msg, opts
func (_m *BccspBCCSP) Hash(msg []byte, opts types.HashOpts) ([]byte, error) {
	ret := _m.Called(msg, opts)

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte, types.HashOpts) ([]byte, error)); ok {
		return rf(msg, opts)
	}
	if rf, ok := ret.Get(0).(func([]byte, types.HashOpts) []byte); ok {
		r0 = rf(msg, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte, types.HashOpts) error); ok {
		r1 = rf(msg, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KeyDeriv provides a mock function with given fields: k, opts
func (_m *BccspBCCSP) KeyDeriv(k types.Key, opts types.KeyDerivOpts) (types.Key, error) {
	ret := _m.Called(k, opts)

	var r0 types.Key
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Key, types.KeyDerivOpts) (types.Key, error)); ok {
		return rf(k, opts)
	}
	if rf, ok := ret.Get(0).(func(types.Key, types.KeyDerivOpts) types.Key); ok {
		r0 = rf(k, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.Key)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Key, types.KeyDerivOpts) error); ok {
		r1 = rf(k, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KeyGen provides a mock function with given fields: opts
func (_m *BccspBCCSP) KeyGen(opts types.KeyGenOpts) (types.Key, error) {
	ret := _m.Called(opts)

	var r0 types.Key
	var r1 error
	if rf, ok := ret.Get(0).(func(types.KeyGenOpts) (types.Key, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(types.KeyGenOpts) types.Key); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.Key)
		}
	}

	if rf, ok := ret.Get(1).(func(types.KeyGenOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KeyImport provides a mock function with given fields: raw, opts
func (_m *BccspBCCSP) KeyImport(raw interface{}, opts types.KeyImportOpts) (types.Key, error) {
	ret := _m.Called(raw, opts)

	var r0 types.Key
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, types.KeyImportOpts) (types.Key, error)); ok {
		return rf(raw, opts)
	}
	if rf, ok := ret.Get(0).(func(interface{}, types.KeyImportOpts) types.Key); ok {
		r0 = rf(raw, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.Key)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, types.KeyImportOpts) error); ok {
		r1 = rf(raw, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Sign provides a mock function with given fields: k, digest, opts
func (_m *BccspBCCSP) Sign(k types.Key, digest []byte, opts types.SignerOpts) ([]byte, error) {
	ret := _m.Called(k, digest, opts)

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Key, []byte, types.SignerOpts) ([]byte, error)); ok {
		return rf(k, digest, opts)
	}
	if rf, ok := ret.Get(0).(func(types.Key, []byte, types.SignerOpts) []byte); ok {
		r0 = rf(k, digest, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Key, []byte, types.SignerOpts) error); ok {
		r1 = rf(k, digest, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Verify provides a mock function with given fields: k, signature, digest, opts
func (_m *BccspBCCSP) Verify(k types.Key, signature []byte, digest []byte, opts types.SignerOpts) (bool, error) {
	ret := _m.Called(k, signature, digest, opts)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Key, []byte, []byte, types.SignerOpts) (bool, error)); ok {
		return rf(k, signature, digest, opts)
	}
	if rf, ok := ret.Get(0).(func(types.Key, []byte, []byte, types.SignerOpts) bool); ok {
		r0 = rf(k, signature, digest, opts)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(types.Key, []byte, []byte, types.SignerOpts) error); ok {
		r1 = rf(k, signature, digest, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewBccspBCCSP creates a new instance of BccspBCCSP. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBccspBCCSP(t interface {
	mock.TestingT
	Cleanup(func())
}) *BccspBCCSP {
	mock := &BccspBCCSP{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
